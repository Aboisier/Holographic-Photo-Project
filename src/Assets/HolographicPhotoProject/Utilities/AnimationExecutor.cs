// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.

using UnityEngine;

namespace HolographicPhotoProject.Utilities
{
    public struct KeyFrame
    {
        public Vector3 LocalPosition;
        public Vector3 LocalRotation;
        public Vector3 LocalScale;
    }

    public class AnimationExecutor : MonoBehaviour
    {
        private static class Constants
        {
            public const float FramesComparisonPrecision = 0.00001f;
        }

        /// <summary>
        /// True if currently executing an animation.
        /// </summary>
        public bool IsInAnimation { get { return time < duration; } }

        private float time = 0;
        private float duration;
        private KeyFrame endKeyFrame;
        private KeyFrame startKeyFrame;

        private bool animatePosition;
        private bool animateRotation;
        private bool animateScale;

        private void Update()
        {
            if (!IsInAnimation)
            {
                return;
            }

            time += Time.deltaTime;
            ApplyKeyFrame(startKeyFrame, endKeyFrame, time / duration);
        }

        /// <summary>
        /// Starts an animated interpolation between the current position of the object and the given keyframe.
        /// </summary>
        /// <param name="keyFrame">The final transform of the object.</param>
        /// <param name="duration">Duration of the animation.</param>
        /// <param name="animatePosition">Determines if position can be changed in the animation.</param>
        /// <param name="animateRotation">Determines if rotation can be changed in the animation.</param>
        /// <param name="animateScale">Determines if scale can be changed in the animation.</param>
        public void StartAnimation(KeyFrame keyFrame, float duration, bool animatePosition = true, bool animateRotation = true, bool animateScale = true)
        {
            startKeyFrame = SaveKeyFrame(gameObject);
            endKeyFrame = keyFrame;
            time = 0;
            this.duration = duration;
            this.animatePosition = animatePosition;
            this.animateRotation = animateRotation;
            this.animateScale = animateScale;
        }

        /// <summary>
        /// Takes a snapshot of the given gameobject, and returns it as an AnimationKeyFrame.
        /// </summary>
        public static KeyFrame SaveKeyFrame(GameObject go)
        {
            KeyFrame keyframe;
            keyframe.LocalPosition = go.transform.localPosition;
            keyframe.LocalRotation = go.transform.localEulerAngles;
            keyframe.LocalScale = go.transform.localScale;

            return keyframe;
        }

        /// <summary>
        /// Applies a animation frame to the object. The frame is generated by an easing function applied to two frames.
        /// </summary>
        /// <param name="start">The starting animation frame.</param>
        /// <param name="end">The ending animation frame.</param>
        /// <param name="value">Value between 0 and 1. Represents the weight given to the ending frame.</param>
        private void ApplyKeyFrame(KeyFrame start, KeyFrame end, float value)
        {
            if (animatePosition && !AreVectorsEqual(start.LocalPosition, end.LocalPosition, Constants.FramesComparisonPrecision))
            {
                transform.localPosition = Berp(start.LocalPosition, end.LocalPosition, value);
            }

            if ((animateRotation) && !AreVectorsEqual(start.LocalRotation, end.LocalRotation, Constants.FramesComparisonPrecision))
            {
                transform.eulerAngles = Berp(start.LocalRotation, end.LocalRotation, value);
            }

            if ((animateScale) && !AreVectorsEqual(start.LocalScale, end.LocalScale, Constants.FramesComparisonPrecision))
            {
                transform.localScale = Berp(start.LocalScale, end.LocalScale, value);
            }
        }

        /// <summary>
        /// Applies a keyframe to a gameObject.
        /// </summary>
        public static void ApplyKeyFrame(GameObject gameObject, KeyFrame keyFrame)
        {
            gameObject.transform.localPosition = keyFrame.LocalPosition;
            gameObject.transform.localEulerAngles = keyFrame.LocalRotation;
            gameObject.transform.localScale = keyFrame.LocalScale;
        }

        /// <summary>
        /// Short for 'boing-like interpolation', this method will first overshoot, then waver back and forth around the end value before coming to a rest.
        /// Src : http://wiki.unity3d.com/index.php?title=Mathfx, the constants were changed.
        /// </summary>
        /// <param name="value">
        /// Value between 0 and 1 indicating the weight of end.
        /// </param>
        private static float Berp(float start, float end, float value)
        {
            value = Mathf.Clamp01(value);
            value = (Mathf.Sin(value * Mathf.PI * (0.1f + 2.0f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + (1.2f * (1f - value)));
            return start + (end - start) * value;
        }

        /// <summary>
        /// Short for 'boing-like interpolation', this method will first overshoot, then waver back and forth around the end value before coming to a rest.
        /// Src : http://wiki.unity3d.com/index.php?title=Mathfx, the constants were changed.
        /// </summary>
        /// <param name="value">
        /// Value between 0 and 1 indicating the weight of end.
        /// </param>
        private static Vector3 Berp(Vector3 start, Vector3 end, float value)
        {
            return new Vector3(Berp(start.x, end.x, value), Berp(start.y, end.y, value), Berp(start.z, end.z, value));
        }

        private static bool AreVectorsEqual(Vector3 vectorA, Vector3 vectorB, float precision)
        {
            var difference = vectorA - vectorB;

            return Mathf.Abs(difference.x) < precision
                   && Mathf.Abs(difference.y) < precision
                   && Mathf.Abs(difference.z) < precision;
        }
    }
}